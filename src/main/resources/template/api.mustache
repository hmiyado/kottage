{{>licenseInfo}}
package {{apiPackage}}

import io.ktor.application.*
import io.ktor.auth.*
import io.ktor.http.*
import io.ktor.response.*
import {{packageName}}.Paths
import io.ktor.routing.*
import io.ktor.util.pipeline.PipelineContext
import io.ktor.request.receive
import kotlinx.serialization.SerializationException
{{#imports}}import {{import}}
{{/imports}}

// this file overrides default template.
// default template is below.
// https://github.com/OpenAPITools/openapi-generator/blob/463d905664498ac0c4006a4b888c39c9359dbcba/modules/openapi-generator/src/main/resources/kotlin-server/libraries/ktor/api.mustache
object OpenApi {
    class RequestBodyUnrecognizableException(override val cause: Throwable?) : SerializationException(cause)

    @Throws(RequestBodyUnrecognizableException::class)
    private suspend inline fun <reified T : Any> ApplicationCall.receiveOrThrow(): T {
        return try {
            receive<T>()
        } catch (e: SerializationException) {
            throw RequestBodyUnrecognizableException(e)
        }
    }

{{#operations}}
    {{#operation}}
        {{#bodyParam.dataType}}
        {{#hasAuthMethods}}
            {{#authMethods}}
        fun Route.{{operationId}}(handler: suspend PipelineContext<Unit, ApplicationCall>.(payload: {{bodyParam.dataType}}, userId: Long)-> Unit) {
            authenticate("{{{name}}}") {
            {{/authMethods}}
        {{/hasAuthMethods}}
        {{^hasAuthMethods}}
        fun Route.{{operationId}}(handler: suspend PipelineContext<Unit, ApplicationCall>.(payload: {{bodyParam.dataType}})-> Unit) {
        {{/hasAuthMethods}}
                {{#lambda.lowercase}}{{httpMethod}}{{/lambda.lowercase}}(Paths.{{operationId}}) {
                {{#hasAuthMethods}}
                    val principal = call.authentication.principal<UserIdPrincipal>()
                    val userId = principal?.name?.toLongOrNull()
                    if (userId == null) {
                        call.respond(HttpStatusCode.Unauthorized)
                        return@{{#lambda.lowercase}}{{httpMethod}}{{/lambda.lowercase}}
                    }
                {{/hasAuthMethods}}

                    val payload = call.receiveOrThrow<{{bodyParam.dataType}}>()
                {{#hasAuthMethods}}
                    handler(payload, userId)
                {{/hasAuthMethods}}
                {{^hasAuthMethods}}
                    handler(payload)
                {{/hasAuthMethods}}
                }
        {{#hasAuthMethods}}
            }
        {{/hasAuthMethods}}
        }
        {{/bodyParam.dataType}}
        {{^bodyParam.dataType}}
        {{#hasAuthMethods}}
            {{#authMethods}}
        fun Route.{{operationId}}(handler: suspend PipelineContext<Unit, ApplicationCall>.(userId: Long)-> Unit) {
            authenticate("{{{name}}}") {
            {{/authMethods}}
        {{/hasAuthMethods}}
        {{^hasAuthMethods}}
        fun Route.{{operationId}}(handler: suspend PipelineContext<Unit, ApplicationCall>.()-> Unit) {
        {{/hasAuthMethods}}
                {{#lambda.lowercase}}{{httpMethod}}{{/lambda.lowercase}}(Paths.{{operationId}}) {
                {{#hasAuthMethods}}
                    val principal = call.authentication.principal<UserIdPrincipal>()
                    val userId = principal?.name?.toLongOrNull()
                    if (userId == null) {
                        call.respond(HttpStatusCode.Unauthorized)
                        return@{{#lambda.lowercase}}{{httpMethod}}{{/lambda.lowercase}}
                    }
                {{/hasAuthMethods}}
                {{#hasAuthMethods}}
                    handler(userId)
                {{/hasAuthMethods}}
                {{^hasAuthMethods}}
                    handler()
                {{/hasAuthMethods}}
                }
        {{#hasAuthMethods}}
            }
        {{/hasAuthMethods}}
        }
        {{/bodyParam.dataType}}
    {{/operation}}
{{/operations}}
}
